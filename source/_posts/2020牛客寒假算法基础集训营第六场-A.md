---
title: 2020牛客寒假算法基础集训营第六场--A
date: 2020-02-21 18:07:42
tags:
---

### 题目
[title](https://ac.nowcoder.com/acm/contest/3007/A)

### 反思
一开始看这道题觉得把所有相加排序就好了，emmm，然后就错了，因为没有注意到**一一对应**这四个字，wa地一脸懵逼，好了终于注意到了，由于是比赛然后心太急没想清楚继续wa，心态已经要崩了，根本没心思细想，直到今天，才把这道题补了，补题过程中还是很粗心啊，这个毛病一定得改，因为隔了几天，心静了下来，所以就慢慢地找规律了，找到后发现其实不难，为什么我当时就做不出来呢真的是，呜呜呜。
-太粗心
-心太急太浮躁
-太懒
希望可以可以慢慢改掉

### 规律
假设k为5，A,B数组进行由小到大排序，那么第k大和肯定存在A,B第k大之后的数对和中，经过一系列地举例子寻找之后发现,例如：
A 1 2 3 4 5 6 7
B 1 4 7 9 10 13 16
第K大后的数为
3 4 5 6 7
7 9 10 13 16
现在地问题就转化为怎么找出这五个数对使得第K大和最大。算一算就知道数对应该是
3--16     5--10     7--7
4--13     6--9
于是将这五和和存进数组排序找出第K大个和就ok了。当然可以不排序，因为这里刚好就是k个数和，直接用min找出最小的就ok了。

### ac代码
```
#include <iostream>
#include <algorithm>
using namespace std;
int a[100005],b[100005],c[100005];
int main() {
    int n, k,t=0;
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < n; i++) {
        cin >> b[i];
    }
    sort(a,a+n);
    sort(b,b+n);
    for (int i=n-1;i>=n-k;i--){
        c[t]=a[i]+b[2*n-k-1-i];
        t++;
    }
    sort(c,c+k);
    cout<<c[0];
}
```